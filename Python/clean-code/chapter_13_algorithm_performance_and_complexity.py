"""Измерение быстродействия и анализ сложности алгоритмов."""

# # Модуль timeit

# ### Хорошее правило
# Сначала добейтесь того, чтобы ваш код работал, а потом занимайтесь его ускорением.
# Сначала работоспособность, потом эффективность!

# +
import cProfile
import timeit

# или так
# Для измерения времени выполнения кода можно воспользоваться
# модулем timeit

timeit.timeit("a, b = 42, 101; a = a ^ b; b = a ^ b; a = a ^ b")
# -

# или так
timeit.timeit(
    """a, b = 42, 101
a = a ^ b
b = a ^ b
a = a ^ b"""
)

timeit.timeit("a, b = 42, 101; temp = a; a = b; b = temp")

# или так
timeit.timeit("a, b = 42, 101; a, b = b, a")

# По умолчанию код будет выполнен 1000000 раз и будет возвращено среднее время выполнения
# Но можно явно указать, сколько раз выполнить код
timeit.timeit('print("hello")', number=3)


# # Модуль cProfile

# Хотя модуль timeit полезен для хронометража небольших фрагментов кода, модуль
# cProfile более эффективен для анализа целых функций или программ.


# +
def add_up_numbers() -> None:
    """Суммирует все числа от 1 до 1 000 000."""
    total = 0
    for i in range(1, 1000001):
        total += i


cProfile.run("add_up_numbers()")
# -

# ## Закон Амдала
# Это формула, которая вычисляет, насколько ускорится выполнение программы при улучшении одного из ее фрагментов.
# Согласно этой формуле ускорение всей операции равно:
#
# 1 / ((1 — p) + (p / s))
#
# где s — ускорение компонента, а p — доля этого компонента в общем времени выполнения программы.
#
# Удвоение скорости самых медленных или длинных частей вашего кода более продуктивно, чем удвоение
# скорости уже быстрых или коротких частей.

# ### Анализ алгоритмов с использованием нотации «O-большое»

# Это метод анализа, который определяет «насколько замедлится код с ростом объема данных».
#
# 1. O(1) – постоянное время (самый низкий порядок).
# 2. O(log n) – логарифмическое время.
# 3. O(n) – линейное время.
# 4. O(n log n) – время N-Log-N.
# 5. O(n^2) – полиномиальное время.
# 6. O(2^n) – экспоненциальное время.
# 7. O(n!) – факториальное время (наивысший порядок).

# «О-большое» оценивает худший сценарий для любой задачи.
#
# «Омега-большое» оценивает лучший сценарий для алгоритма (Ω(n), Ω(log n) и т.д.).
#
# «Тэта-большое» описывает алгоритмы с одинаковыми порядками в лучшем и худшем случае. Например, Θ(n) описывает алгоритм с линейной эффективностью в лучшем и худшем случае — то есть алгоритм O(n) и Ω(n).
