"""Макаров.

Функции в Питоне.
"""

# ## Функции в Питоне

# ### Встроенные функции

# +
from collections.abc import ItemsView
from typing import Callable

# импортируем библиотеки
import matplotlib.pyplot as plt

# перед вызовом функции нужно не забыть импортировать
# соответствующую библиотеку
import numpy as np

# установим точку отсчета
np.random.seed(42)
# и снова сгенерируем данные о росте
# (как мы делали на восьмом занятии вводного курса)
height = list(np.round(np.random.normal(180, 10, 1000)))
# -

# #### Параметры и аргументы функции

# теперь построим гистограмму передав ей два параметра,
# данные о росте и количество интервалов
# первый параметр у нас позиционный, второй - именованный
plt.hist(height, bins=10)
plt.show()

# первый параметр можно также сделать именованным (данные обозначаются через x)
# и тогда порядок параметров можно менять
plt.hist(bins=10, x=height)
plt.show()

# у параметра bins есть аргумент по умолчанию (как раз 10 интервалов),
# а значит, этот параметр можно не указывать
plt.hist(height)
plt.show()

# функция может не принимать параметров
print("Первая строка")
print()
print("Третья строка")

# #### Функции и методы

# +
# дана строка
some_string = "machine learning"

# применим метод .title()
some_string.title()

# +
# к списку
some_list: list[str] = ["machine", "learning"]

# этот метод не применить
# some_list.title()
# -

# ### Собственные функции в Питоне

# #### Объявление и вызов функции

# +
# создадим функцию, которая удваивает любое передаваемое ей значение


def double(x_arg: int) -> int:
    """Умножает переданное число на 2."""
    res = x_arg * 2
    return res


# -

# и вызовем ее, передав число 2
double(2)

# #### Пустое тело функции

# +
# тело функции не может быть пустым


def only_return() -> None:
    """Функция с одним return."""
    # нужно либо указать ключевое слово return
    return


# -

only_return()

# +
# либо оператор pass


# def only_pass() -> None:
#     """Функция ничего не делает."""
#     pass

# +
# only_pass()

# +
# такая функция вернет тип данных None (отсутствие значения)
# print(only_return()) -> None
# -

# #### Функция print() вместо return

# +
# можно использовать print(), но есть нюансы (см. на странице урока)


def double_print(x_arg: int) -> None:
    """Функция умножает переданное число на 2 и выводит результат в консоль."""
    res = x_arg * 2
    print(res)


# -

double_print(5)

# #### Параметры собственных функций

# +
# объявим функцию с параметрами x и y


def calc_sum(x_arg: int, y_arg: int) -> int:
    """Функция складывает два целых числа."""
    # и выведем их сумму
    return x_arg + y_arg


# -

# вызовем эту функцию с одним позиционным и одним именованным параметром
calc_sum(1, y_arg=2)

# +
# параметрам функции можно задать аргументы по умолчанию


def calc_sum_default(x_arg: int = 1, y_arg: int = 2) -> int:
    """Функция складывает два целых числа."""
    return x_arg + y_arg


# и при вызове тогда их указывать не обязательно
calc_sum_default()

# +
# функция может не иметь параметров


def print_string() -> None:
    """Функция выводит строку 'Some string'."""
    print("Some string")


print_string()
# -

# #### Аннотация функции

# +
# укажем, что на входе функция принимает тип float, а возвращает int
# значение 3,5 - это значение параметра x по умолчанию


def f(x_arg: float = 3.5) -> int:
    """Функция приводит переданный float-аргумент к целочисленному типу."""
    return int(x_arg)


# -

# желаемый тип данных можно посмотреть через атрибут __annotations__
f.__annotations__

# вызовем функцию без параметров
f()

# +
# сохраним аннотации, но изменим суть функции
# def f(x: float) -> int:
#   # теперь вместо int она будет возвращать float
#   return float(x)
# -

# вновь вызовем функцию, передав ей на входе int, и ожидая на выходе получить float
f(3)

# #### Дополнительные возможности

# вызов функции можно совмещать с арифметическими
result = calc_sum(1, 2) * 2

# и логическими операциями
result = calc_sum(1, 2) > 2

# +
# можно и так


def first_letter() -> str:
    """Функция возвращает строку 'Python'."""
    return "Python"


print(first_letter()[0])

# +
# функция может не принимать параметров, но использовать input()


def use_input() -> int:
    """Функция возводит введенное число в квадрат."""
    # запросим у пользователя число и переведем его в тип данных int
    user_inp = int(input("Введите число: "))

    # возведем число в квадрат
    result_pow = user_inp**2

    # вернем результат
    return result_pow


# вызовем функцию
use_input()
# -

# #### Результат вызова функции

# +
# функция может возвращать также список, кортеж, словарь и др.


# объявим функцию, которая на входе получает число,
# а на выходе формирует список чисел от 0 и до числа, предшествующего заданному
def create_list(x_arg: int) -> list[int]:
    """Создает список,заполненный числами от 0 до x_arg."""
    # создадим пустой список
    my_list: list[int] = []

    # в цикле for создадим последовательность
    for index in range(x_arg):

        # и поместим ее в список
        my_list.append(index)

    return my_list


# результатом вызова этой функции будет список
create_list(5)

# +
# функция может возвращать сразу два значения


def tuple_f() -> tuple[str, int]:
    """Возвращает кортеж ('python', 42)."""
    string = "Python"
    x_arg = 42
    return string, x_arg


# +
# если использовать две переменные
a_var, b_var = tuple_f()

# на выходе мы получим строку и число
print(a_var, b_var)
print(type(a_var), type(b_var))

# +
# если одну
c_var = tuple_f()

# получится кортеж
print(c_var)
print(type(c_var))

# +
# выводом может быть логическое значение (True или False)


def is_divisible(x_arg: int) -> bool:
    """Функция проверяет, является ли число четным."""
    # если остаток от деления на два равен нулю
    if x_arg % 2 == 0:
        # вернем True
        return True

    # в противном случае False
    return False


is_divisible(10)
# -

# #### Использование библиотек

# +
# применим функцию mean() библиотеки Numpy для расчета среднего арифметического


# на входе наша функция примет список или массив x,
def mean_f(x_arg: list[int]) -> float:
    """Функция вычисляет среднее и прибавляет 1 к результату."""
    # рассчитает среднее арифметическое и прибавит единицу
    return float(np.mean(x_arg) + 1)


# +
# и подготовить данные
x_var: list[int] = [1, 2, 3]

mean_f(x_var)
# -

# #### Глобальные и локальные переменные

# +
# создадим глобальную переменную вне функции
global_name = "Петр"

# а затем используем ее внутри новой функции


def show_name() -> None:
    """Функция выводит в консоль глобальную переменную global_name."""
    print(global_name)


# -

show_name()

# +
# а теперь вначале создадим функцию,
# внутри которой объявим локальную переменную


def show_local_name() -> None:
    """Функция выводит в консоль 'Алена'."""
    local_name_1 = "Алена"
    print(local_name_1)


# -

show_local_name()

# +
# при попытке обратиться к переменной вне функции мы получим ошибку
# local_name

# +
# превратить локальную переменную в глобальную можно
# через ключевое слово global
local_name = "Татьяна"


def make_global() -> None:
    """Создает глобальную переменную local_name и выводит ее в консоль."""
    global local_name  # pylint: disable=W0603
    local_name = "Алена"
    print(local_name)


# -

make_global()

# +
# теперь ошибки быть не должно
# local_name

# +
# объявим глобальную переменную
global_number = 5


def print_number() -> None:
    """Выводит в консоль значение локальной переменной local_number."""
    # затем объявим локальную переменную
    local_number = 10
    print("Local number:", local_number)
    print("Global number:", global_number)


# -

# функция всегда "предпочтет" локальную переменную
print_number()

# при этом значение глобальной переменной для остального кода не изменится
print("Global number:", global_number)

# ### Lambda-функции

# +
# создадим функцию, которая принимает два числа и перемножает их
lf: Callable[[int, int], int] = lambda a_arg, b_arg: a_arg * b_arg

# вызовем функцию и передадим ей числа 2 и 3
lf(2, 3)

# +
# этот же функционал можно поместить в обычную функцию


def normal_f(a_arg: int, b_arg: int) -> int:
    """Возвращает произведение переданных аргументов."""
    return a_arg * b_arg


normal_f(2, 3)
# -

# #### Lambda-функция внутри функции filter()

# +
# создадим список
nums_list: list[int] = [15, 27, 9, 18, 3, 1, 4]

# напишем lambda-функцию, которая выведет True,
# если число больше 10, и False, если меньше
is_more_then_10: Callable[[int], bool] = lambda n_arg: n_arg > 10

# поместим список и lambda-функцию в функцию filter()
# и преобразуем результат в список
list(filter(is_more_then_10, nums_list))
# -

# все это можно записать в одну строчку
list(filter(lambda n_arg: n_arg > 10, nums_list))

# +
# ту же задачу можно решить через обычную функцию,
# но придется написать больше кода


def is_more_then_10_2(n_arg: int) -> bool:
    """Функция проверяет, больше ли переданное число 10."""
    if n_arg > 10:
        return True

    return False


list(filter(is_more_then_10_2, nums_list))
# -

# #### Lambda-функция внутри функции sorted()

# +
# напомню, что мы создали список из кортежей,
# и в каждом кортеже был индекс фильма и расстояние до него
indices_distances = [
    (901, 0.0),
    (1002, 0.22982440568634488),
    (442, 0.25401128310081567),
]

# lambda-функция возьмет каждый кортеж и вернет второй [1] его элемент
# передав эту функцию через параметр key, мы отсортируем список по расстоянию
sorted(indices_distances, key=lambda x_arg: x_arg[1], reverse=False)
# -

# #### Немедленно вызываемые функции

# lambda-функцию можно вызвать сразу в момент объявления
(lambda x_arg: x_arg * x_arg)(10)  # pylint: disable=C3002

# ### \*args и \**kwargs

# #### \*args

# +
# напишем функцию для расчета среднего арифметического двух чисел


def mean_simple(a_arg: int, b_arg: int) -> float:
    """Функция вычисляет среднее арифметическое."""
    return (a_arg + b_arg) / 2


# -

mean_simple(1, 2)

# +
# объявим функцию, которой нужно передать список


def mean_1(list_arg: list[int]) -> float:
    """Функция вычисляет среднее арифметическое переданного массива чисел."""
    # зададим переменную для суммы,
    total = 0

    # в цикле сложим все числа из списка
    for num in list_arg:
        total += num

    # и разделим на количество элементов
    return total / len(list_arg)


# +
# создадим список
list_: list[int] = [1, 2, 3, 4]

# и передадим его в новую функцию
mean_1(list_)

# +
# однако новая функция уже не может работать с отдельными числами
# mean(1, 2) -> Error

# +
# объявим функцию с *args


def mean_2(*nums: int) -> float:
    """Функция вычисляет среднее арифметическое переданного массива чисел."""
    # в данном случае мы складываем элементы кортежа
    total = 0
    for num in nums:
        total += num

    return total / len(nums)


# -

# теперь мы можем передать функции отдельные числа
mean_2(1, 2, 3, 4)

# или список
mean_2(*list_)

# +
# убедимся, что оператор распаковки * формирует кортеж


def test_type(*nums: int) -> None:
    """Функция проверят тип аргумента *nums."""
    print(nums, type(nums))


test_type(1, 2, 3, 4)
# -

# со списком происходит то же самое
test_type(*list_)

# +
# для наглядности приведем еще один пример
a_list: list[int] = [1, 2, 3]
b_list: list[int] = [*a_list, 4, 5, 6]

print(b_list)
# -

# #### \**kwargs

# +
# **kwargs преобразует именованные параметры в словарь


def fn(**kwargs: int) -> ItemsView[str, int]:
    """Возвращает список пар ключ/значение именованных параметров."""
    return kwargs.items()


# -

fn(a=1, b=2)

# +
# *nums превращается в кортеж, **params - в словарь


def simple_stats(*nums: int, **params: bool) -> None:
    """Функция вычисляет среднее арифметическое и СКО."""
    # если ключ 'mean' есть в словаре params и его значение == True
    if "mean" in params and params["mean"] is True:

        # рассчитаем среднее арифметическое и округлим
        # \t - это символ табуляции
        print(f"mean: \t{np.round(np.mean(nums), 3)}")

    # если ключ 'std' есть в словаре params и его значение == True
    if "std" in params and params["std"] is True:

        # рассчитаем СКО и округлим
        print(f"std: \t{np.round(np.std(nums), 3)}")


# -

# вызовем функцию simple_stats() и передадим ей числа и именованные аргументы
simple_stats(5, 10, 15, 20, mean=True, std=True)

# если для одного из параметров задать значение False,
# функция не выведет соответствующую метрику
simple_stats(5, 10, 15, 20, mean=True, std=False)

# +
# если мы хотим передать параметры списком и словарем,
list_nums: list[int] = [5, 10, 15, 20]
settings: dict[str, bool] = {"mean": True, "std": True}

# то нам нужно использовать операторы распаковки * и ** соответственно
simple_stats(*list_nums, **settings)
# -

# ничто не мешает нам добавить еще один параметр
simple_stats(5, 10, 15, 20, mean=True, std=True, median=True)
