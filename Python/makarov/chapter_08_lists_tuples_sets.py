"""Макаров.

Списки, кортежи и множества.
"""

# ## Списки, кортежи и множества

# ### Списки

# Основы работы со списками

# +
# пустой список можно создать через [] или функцию list()
# импортируем класс стеммера и создаем объект
from nltk.stem import PorterStemmer

some_list_1: list[str] = []
some_list_2: list[str] = list()  # pylint: disable=R1734

print(some_list_1, some_list_2)
# -

# элементами списка могут, в частности, быть числа, строки,
# другие списки и словари
number_three: list[int | str | list[str] | dict[str, int]] = [
    3,
    "число три",
    ["число", "три"],
    {"число": 3},
]
number_three

# длина списка рассчитывается через функцию len()
len(number_three)

# Индекс и срез списка

# +
# у списка есть положительный и отрицательный индексы
abc_list: list[str] = ["a", "b", "c", "d", "e"]

# воспользуемся ими для вывода первого и последнего элементов
print(abc_list[0], abc_list[-1])

# +
# при работе с вложенным списком
salary_list: list[list[str | int]] = [
    ["Анна", 90000],
    ["Игорь", 85000],
    ["Алексей", 95000],
]

# мы вначале указываем индекс вложенного списка, а затем индекс элемента в нем
salary_list[1][0]
# -

# индекс можно узнать с помощью метода .index()
abc_list.index("c")

# метод .index() можно применить и ко вложенному списку
salary_list[0].index(90000)

# +
# создадим список с днями недели
days_list: list[str] = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"]

# и выведем со второго по пятый элемент включительно
days_list[1:5]
# -

# выведем каждый второй элемент в срезе с первого по пятый
days_list[:5:2]

# проверим есть ли "Пн" в списке
"Пн" in days_list

# если "Вт" есть в списке
if "Вт" in days_list:

    # выведем сообщение
    print("Такое слово есть")

# Добавление, замена и удаление элементов списка

# создадим список
weekdays: list[str] = ["Понедельник", "Вторник"]

# добавим один элемент в конец списка с помощью метода .append()
weekdays.append("Четверг")
weekdays

# добавим элемент в определенное место в списке
# через желаемый индекс этого элемента
weekdays.insert(2, "Среда")
weekdays

# изменим четвертый элемент в списке
weekdays[3] = "Пятница"
weekdays

# удалим элемент по его значению
weekdays.remove("Пятница")
weekdays

# удалим элемент по его индексу через ключевое слово del
del weekdays[2]
weekdays

# сделаем то же самое с помощью метода .pop()
# этот метод выводит удаляемый элемент
weekdays.pop(1)

# посмотрим, что осталось в нашем списке
weekdays

# Сложение списков

# +
# соединить два списка можно с помощью метода .extend()
more_weekdays: list[str] = ["Вторник", "Среда", "Четверг", "Пятница"]

weekdays.extend(more_weekdays)
weekdays

# +
weekend: list[str] = ["Суббота", "Воскресенье"]

# или просто сложив два списка
print(weekdays + weekend)
# -

# иногда бывает полезно "размножить" элементы списка
print(["Понедельник"] * 2)

# такие "произведения" также можно складывать
print(["Понедельник"] * 2 + ["Вторник"] * 2)

# Распаковка списков

# дан список
week: list[str] = [
    "Понедельник",
    "Вторник",
    "Среда",
    "Четверг",
    "Пятница",
    "Суббота",
    "Воскресенье",
]

# указав индекс элемента, его можно записать в переменную
Mon = week[0]
Mon

# +
# срез можно поместить в несколько переменных
Mon, Tue, Wed = week[:3]

# важно, чтобы количество элементов среза было равно количеству переменных
Mon, Tue, Wed
# -

# можно выделить первый элемент, а остальные поместить
# в переменную со звездочкой
Mon, *rest = week
Mon

# также можно поступить, например, с первым и последним элементом
Mon, *days, Sun = week
Mon, Sun

# посмотрим, какие элементы остались в переменной со звездочкой
days

# Сортировка списков

# возьмем список чисел
nums: list[int] = [25, 10, 30, 20, 5, 15]

# и отсортируем с помощью функции sorted(), результат выводится сразу
sorted(nums)

# исходный список при этом не изменился
nums

# если поместить результат в переменную, изменения сохранятся
sorted_nums = sorted(nums)
sorted_nums

# метод .sort() сохраняет результат, но не выводит его сразу
# reverse = True задает сортировку по убыванию
nums.sort(reverse=True)

# выведем результат
nums

# +
# метод .reverse() задает обратный порядок, сохраняет, но не выводит результат
nums.reverse()

# его также нужно вывести отдельно
nums
# -

# функция reversed() возвращает итератор
reversed(nums)

# вывести результат можно с помощью функции list()
list(reversed(nums))

# результат при этом не сохраняется
nums

# Преобразование списка в строку

# дан список из строковых элементов
str_list: list[str] = ["P", "y", "t", "h", "o", "n"]

# с помощью метода .join() можно соединить все элементы
joined_str = "".join(str_list)
joined_str

# если в кавычках ничего не указывать, элементы просто соединятся,
# но можно указать любой другой элемент
joined_str_ = "_".join(str_list)
joined_str_

# Арифметика в списках

# дан список чисел
nums_: list[int] = [3, 2, 1, 4, 5, 12, 3, 3, 7, 9, 11, 15]

# с помощью метода .count() мы можем посчитать частоту вхождения
# элемента в список
nums_.count(3)

# кроме того мы можем найти минимальное и максимальное значения
# и сумму элементов
print(min(nums_), max(nums_), sum(nums_))

# List comprehension

# дан список имен
# оставим имена, начинающиеся с буквы "А"
names: list[str] = [
    "Артем",
    "Антон",
    "Александр",
    "Борис",
    "Виктор",
    "Геннадий",
]

# +
# вначале решим эту задачу с помощью цикла for

# создадим пустой список
a_names: list[str] = []

# пройдемся по исходному списку в цикле for
for name in names:

    # с помощью метода .startswith() проверим, начинается ли слово с "А"
    if name.startswith("А"):

        # если да, добавим в новый список
        a_names.append(name)

# выведем результат
a_names
# -

# эту же задачу можно решить через list comprehension
# по сути мы пишем: "что сделать, пока есть элемент в списке, при каком условии"
a_names = [name for name in names if name.startswith("А")]
a_names

# переведем все буквы в строчные, условие здесь не нужно
lower_names = [name.lower() for name in names]
lower_names

# схема условия if-else немного отличается
# оставляем имя, если это не Виктор, если Виктор - заменяем на Вадим
replace_name = [name if name != "Виктор" else "Вадим" for name in names]
replace_name

# +
# на занятии по обработке естественного языка с помощью list comprehension
# мы применили стеммер Портера к списку слов
lemmatized: list[str] = [
    "paris",
    "visited",
    "lot",
    "museum",
    "first",
    "went",
    "louvre",
    "largest",
    "art",
    "museum",
    "world",
    "always",
    "interested",
    "art",
    "spent",
    "many",
    "hour",
    "museum",
    "enormous",
    "week",
    "would",
    "enough",
]


porter = PorterStemmer()

# применяем стеммер к элементу s, пока есть элементы s в списке lemmatized
stemmed_p = [porter.stem(s) for s in lemmatized]
print(stemmed_p)
# -

# ### Кортежи

# Основы работы с кортежами

# пустой кортеж можно создать с помощью пустых круглых скобок ()
# или функции tuple()
tuple_1: tuple[()] = ()
tuple_2: tuple[str, ...] = tuple()
print(tuple_1, tuple_2)

# в кортеже элементы упорядочены, а значит есть индекс
letters: tuple[str, ...] = ("a", "b", "c")
letters[0]

# +
# но изменить элемент, как мы это делали в списке, нельзя
# letters[0] = "d" --> Error
# -

# для изменения элемента кортеж вначале нужно преобразовать в список
letters_list = list(letters)
letters_list[0] = "d"
letters_list

# кортеж из одного элемента можно создать с помощью запятой
letters_a: tuple[str] = ("a",)
type(letters_a)

# если запятую не указывать, получится строка
a_let = "a"
type(a_let)

# Функция enumerate()

# +
companies: list[str] = ["Microsoft", "Apple", "Tesla"]

# если записать результат функции enumerate() в одну переменную,
for company in enumerate(companies):

    # то мы получим кортежи
    print(company, type(company))
# -

# Просмотр элементов словаря

shopping_dict: dict[str, int] = {
    "огурцы": 2,
    "помидоры": 3,
    "лук": 1,
    "картофель": 2,
}

# то же самое со словарем и методом .items()
for item in shopping_dict.items():
    print(item)

# Распаковка кортежей

# как и список, кортеж можно распаковать в несколько переменных
a_let, b_let, c_let = ("a", "b", "c")
print(a_let)

# +
companies = ["Microsoft", "Apple", "Tesla"]

# распаковку в две переменные с функцией enumerate() мы делать уже умеем
for index, company_name in enumerate(companies):
    print(index, company_name)

# +
shopping_dict = {
    "огурцы": 2,
    "помидоры": 3,
    "лук": 1,
    "картофель": 2,
}

# то же самое с ключами и значениями словаря
for key, value in shopping_dict.items():
    print(key, value)
# -

# Функция zip()

# +
# если есть два и более списка
names = [
    "Артем",
    "Антон",
    "Александр",
    "Борис",
    "Виктор",
    "Геннадий",
]
income: list[int] = [97000, 110000, 95000, 84000, 140000, 120000]

# функция zip() соединит первые элементы списков,
# вторые элементы списков и т.д.
zip(names, income)
# -

# для вывода результата нужно передать zip-объект в функцию list()
# на выходе мы получим список из кортежей
print(list(zip(names, income)))

# ### Множества

# Создание множества

# +
# пустое множество задается через функцию set()
set_1: set[str] = set()

# непустое множество задается через функцию set() и итератор
# например, список элементов или строку
set_2: set[str] = set("abcde")  # pylint: disable=W0130

# или путем перечисления элементов в фигурных скобках {}
set_3: set[str] = {"a", "b", "c", "c"}  # pylint: disable=W0130

# множество содержит только уникальные элементы, поэтому дубликаты удаляются
print(set_1, set_2, set_3)

# +
# создать множество через пустые фигурные скобки нельзя
not_a_set: dict[str, str] = {}

# так создается словарь
type(not_a_set)
# -

# Добавление и удаление элементов

# предположим, что мы хотим создать множество гласных букв в русском языке
vowels: set[str] = {"а", "о", "э", "е", "у", "ё", "ю"}

# добавим одну букву "я" методом .add()
vowels.add("я")
vowels

# добавим две буквы "и" и "ы" методом .update()
vowels.update(["и", "ы"])
vowels

# если по ошибке мы добавим согласную букву,
vowels.add("щ")
vowels

# ее можно удалить методом .remove()
vowels.remove("щ")
vowels

# Теория множеств в Питоне

# два множества равны, если содержат одинаковые элементы,
# при этом порядок элементов не важен
print({"a", "b", "c"} == {"c", "b", "a"})

# выведем мощность множества с помощью функции len()
print(len({"a", "b", "c"}))

# проверим, содержится ли элемент во множестве
print("a" in {"a", "b", "c"})

# возможна и обратная операция
print("a" not in {"a", "b", "c"})

# +
# проверим является ли А подмножеством В
set_a: set[str] = {"a", "b", "c"}
set_b: set[str] = {"a", "b", "c", "d", "e", "f"}

set_a.issubset(set_b)
# -

# проверим является ли B надмножеством А
set_b.issuperset(set_a)

# даны участники команд по обработке естественного языка (nlp)
# и компьютерному зрению (cv)
nlp: set[str] = {"Анна", "Николай", "Павел", "Оксана"}
cv: set[str] = {"Николай", "Евгений", "Ольга", "Оксана"}

# +
# найдем тех, кто работает или в nlp, или в cv, или в обеих командах

# можно использовать метод .union()
print(nlp.union(cv))

# или символ |
print(nlp | cv)
# -

# найдем пересечение множеств, то есть тех, кто работает и в nlp, и в cv
print(nlp.intersection(cv))
print(nlp & cv)

# выведем тех, кто работает только в nlp, но не в cv или cv и nlp одновременно
print(nlp.difference(cv))
print(nlp - cv)

# выведем тех, кто работает только в cv,
# но не в nlp или nlp и cv одновременно
print(cv.difference(nlp))
print(cv - nlp)

# найдем тех, кто работает или в cv, или в nlp,
# но не в обеих областях одновременно
print(nlp.symmetric_difference(cv))
print(nlp ^ cv)
